#!/usr/bin/python
#
# Copyright (C) 2012 Intel Corporation
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# Authors:
#              Zhang, Huihui <huihuix.zhang@intel.com>
#              Wendong,Sui  <weidongx.sun@intel.com>
#              Yuanyuan,Zou  <yuanyuan.zou@borqs.com>
""" testkit lite tools"""

import os
import sys, traceback
import platform
import ConfigParser
import xml.etree.ElementTree as etree
from optparse import OptionParser, make_option
from datetime import datetime

JOIN = os.path.join
EXISTS = os.path.exists
DIRNAME = os.path.dirname
BASENAME = os.path.basename
ABSPATH = os.path.abspath

testkit_dir = "/opt/testkit/lite"
if not platform.system() == "Linux":
    testkit_dir = DIRNAME(ABSPATH(__file__))
    sys.path += [JOIN(testkit_dir)]
    testkit_dir = JOIN(testkit_dir , "results")

LOG_DIR = testkit_dir
PID_FILE = JOIN(LOG_DIR , "pid.log")
COMMON_FILTERS = {
        "suite":          [],
        "set":            [],
        "id":             [],
        "type":           [],
        "priority":       [],
        "category":       [],
        "status":         [],
        "component":      []}

# start testkit-lite in Singleton mode

if not platform.system() == "Linux":
    try:
        if not os.path.exists(LOG_DIR):
            os.makedirs(LOG_DIR)
    except IOError, e:
        print "[ Error: create results directory: %s failed, \
        error: %s ]\n" % (LOG_DIR, e)

try:
    with open(PID_FILE, "w") as fd:
        pid = str(os.getpid())
        fd.writelines(pid + '\n')
except IOError, e:
    print "[ Error: can't create pid log file: %s, \
    error: %s ]\n" % (PID_FILE, e)
    sys.exit(1)

try:
    os.chmod(PID_FILE, 0666)
except IOError, e:
    pass

# detect version option
if "--version" in sys.argv:
    try:
        config = ConfigParser.ConfigParser()
        if platform.system() == "Linux":
            config.read('/opt/testkit/lite/VERSION')
        else:
            version_file = os.path.join(sys.path[0], 'VERSION')
            config.read(version_file)
        VERSION = config.get('public_version', 'version')
        print "V%s" % VERSION
    except Exception, e:
        print "[ Error: fail to parse version info, error: %s ]\n" % e
    sys.exit(1)

# detect internal version option
if "--internal-version" in sys.argv:
    try:
        config = ConfigParser.ConfigParser()
        if platform.system() == "Linux":
            config.read('/opt/testkit/lite/VERSION')
        else:
            version_file = os.path.join(sys.path[0], 'VERSION')
            config.read(version_file)
        VERSION = config.get('internal_version', 'version')
        print VERSION
    except Exception, e:
        print "[ Error: fail to parse version info, error: %s ]\n" % e
    sys.exit(1)

# get test engine, now we only got default engine
if "-E" in sys.argv:
    index = sys.argv.index("-E")
    try:
        engine = sys.argv[index + 1]
        engine = str(engine.strip()).lower()
    except IndexError:
        engine = "default"
else:
    engine = "default"

# init test engine here
try:
    exec "from testkitlite.engines.%s.runner import TRunner" % engine
    print "[ loading %s test engine ]" % engine
except ImportError, e:
    print "[ Error: loading test engine: %s failed, error: %s ]\n" % (engine, e)
    print "try to run command \
    'export PYTHONPATH=/usr/lib/python2.7/site-packages' to resolve this issue"
    sys.exit(1)

def varnarg(option, opt_str, value, parser):
    """ parser srg"""
    value = []
    import re
    for arg in parser.rargs:
        if re.search('^--.+', arg) or \
           re.search('^-[\D]', arg):
            break
        value.append(arg)
        
    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, value)

try:
    option_list = [
        make_option("-f", "--testxml", dest="testxml",
                    action="callback", callback=varnarg,
                    help="Specify the test.xml. \
                    If run more the one testxml, \
                    just list them all and separate with a whitespace"),
        make_option("-D", "--dryrun", dest="bdryrun",
                    action="store_true",
                    help="Dry-run the selected test cases"),
        make_option("-M", "--manual-only", dest="bmanualonly",
                    action="store_true",
                    help="Enable only manual tests"),
        make_option("-A", "--auto-only", dest="bautoonly",
                    action="store_true",
                    help="Enable only auto tests"),
        make_option("-o", "--output", dest="resultfile",
                    help="Specify output file for result xml. \
                    If more than one testxml provided, \
                    results will be merged together to this output file"),
        make_option("-E", dest="engine", help="Specific test engine"),
        make_option("-e", dest="exttest", action="store",
                    help="Launch external test with an executable file"),
        make_option("--fullscreen", dest="fullscreen", 
                    action="store_true",
                    help="Run web API test in full screen mode"),
        make_option("--non-active", dest="non_active", 
                    action="store_true",
                    help="Disable the ability to set the result of \
                    core manual cases from the console"),
        make_option("--enable-memory-collection", 
                    dest="enable_memory_collection", action="store_true",
                    help="Enable the ability to release memory \
                    when the free memory is less than 100M"),
        make_option("--version", dest="version_info", action="store_true",
                    help="Show version information"),
        make_option("--internal-version", dest="internal_version_info", 
                    action="store_true",
                    help="Show internal version information"),
        make_option("--deviceid",dest="device_serial",
                    action="store",
                    help="set sdb device serial information")
        ]
    
    option_list.extend(map(lambda flt: \
                make_option("--%s" % flt, dest="w%s" % flt, \
                    action="callback", callback=varnarg, \
                    help="Select the specified filter-rules : %s" % flt), \
                    COMMON_FILTERS))

    try:
        # untrusted behaviour of %%prog
        usage = "%%prog [options] -f <somewhere/test.xml>\n\
examples: %%prog  -f  <somewhere>/test.xml\n\
          %%prog  -f test.xml -D\n\
          %%prog  -f test.xml -A\n\
          %%prog  -f test.xml -M\n\
          %%prog  -f test1.xml test2.xml test3.xml ...\n\
          %%prog  -f test.xml -D -A --type type1 ...\n\
          %%prog  -f test.xml -D -A --type type1 --status ready ...\n\
\n\
    run a webapi package: \n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml --priority P0 --status ready ...\n\
    run both core and webapi packages: \n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml /usr/share/tts-bluez-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml ...\n\
\n\
Note: \n\
          1) Proxy settings should be disabled when execute webapi packages\n\
          2) TestLog is stored to %s/latest\n\
          3) %%prog enables both auto and manual tests by default\n\
          4) Obviously -A and -M are conflict options\n\
          5) -e option does not support -D mode\n\
          6) The test cases' order in the result files might be arbitrary, when running same tests.xml with same options. This is caused by python's API 'getiterator' from module 'xml.etree.ElementTree'\n\
          7) run command 'testkit-lite', it might not be able to locate module 'testkitlite.engines.default.runner', run command 'export PYTHONPATH=/usr/lib/python2.7/site-packages' to resolve this issue" % (LOG_DIR)
    except Exception:
        usage = None

    # detect non-params
    if len(sys.argv) == 1:
        sys.argv.append("-h")

    parsers = OptionParser(option_list=option_list, usage=usage)

    (options, args) = parsers.parse_args()

    # detect conflict
    if options.bautoonly and options.bmanualonly:
        raise ValueError("-A and -M are conflict")

    # create runner
    runner = TRunner()
    runner.set_pid_log(PID_FILE)
    # apply all options 
    runner.set_global_parameters(options)

    #check if there is a device_serial
    if not options.device_serial and options.testxml:
        print "[ Error: not specify a device_serial... ]\n"
        sys.exit(1)

    # apply filter
    wfilters = {}
    for flt in COMMON_FILTERS:
        if eval('options.w%s' % flt):
            wfilters[flt] = eval('options.w%s' % flt)
    runner.add_filter_rules(**wfilters)

    if not options.testxml:
        print "[ Error: not specify a test xml... ]\n"
        sys.exit(1)

    # 1) prepare log dir
    if platform.system() == "Linux":
        session = datetime.today().isoformat('-')
    else:
        session = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
    log_dir = JOIN(LOG_DIR, session)
    latest_dir = JOIN(LOG_DIR, "latest")
    try:
        if EXISTS(latest_dir):
            os.remove(latest_dir)
        os.makedirs(log_dir)
        if os.name == "posix":
            os.symlink(log_dir, latest_dir)
    except IOError, e:
        print "[ Error: create session log directory: \
        %s failed, error: %s ]\n" % (log_dir, e)

    # 2) run test
    # run more than one tests.xml
    # 1. run all auto cases from the xmls
    # 2. run all manual cases from the xmls
    if len(options.testxml) > 1:
        testxmls = set(options.testxml)
        for t in testxmls:
            filename = t
            filename = os.path.splitext(filename)[0]
            if platform.system() == "Linux":
                if not filename.startswith('/'):
                    print "[ Error: xml file %s should start \
                    with '/' ]" % filename
                    sys.exit(1)
                else:
                    filename = filename.split('/')[-2]
                    if filename == "":
                        print "[ Error: unable to find package name info \
                        from %s ]" % t
                        sys.exit(1)
            else:
                filename = filename.split('\\')[-2]
            filename = "%s.total" % BASENAME(filename)
            resultfile = "%s.xml" % filename
            resultfile = JOIN(log_dir, resultfile)
            ep = etree.parse(t)
            suiteparent = ep.getroot()
            no_test_definition = 1
            for tf in ep.getiterator('test_definition'):
                no_test_definition = 0
            if no_test_definition:
                suiteparent = etree.Element('test_definition')
                suiteparent.tail = "\n"
                for suite in ep.getiterator('suite'):
                    suite.tail = "\n"
                    suiteparent.append(suite)
            if options.bautoonly:
                wfilters['execution_type'] = ["auto"]
                runner.add_filter_rules(**wfilters)
            if options.bmanualonly:
                wfilters['execution_type'] = ["manual"]
                runner.add_filter_rules(**wfilters)
            runner.apply_filter(suiteparent)
            # just leave suite and set for merge result
            for suite in ep.getiterator('suite'):
                for tset in suite.getiterator('set'):
                    for testcase in tset.getiterator('testcase'):
                        tset.remove(testcase)
            try:
                with open(resultfile, 'w') as output:
                    tree = etree.ElementTree(element=suiteparent)
                    tree.write(output)
            except IOError, e:
                print "[ Error: create filtered total result file: \
                %s failed, error: %s ]\n" % (resultfile, e)
        START_TIME = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        if not options.bautoonly:
            if options.bmanualonly:
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["manual"]
                        runner.add_filter_rules(**wfilters)
                        runner.prepare_run(t, resultdir=log_dir)
                    except IOError, e:
                        print "[ Error: prepare_run test xml: \
                        %s from testkit-lite failed, error: %s ]\n" % (t, e)
            else:
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["auto"]
                        runner.add_filter_rules(**wfilters)
                        runner.prepare_run(t, resultdir=log_dir)
                    except IOError, e:
                        print "[ Error: prepare_run test xml: \
                        %s from testkit-lite failed, error: %s ]\n" % (t, e)
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["manual"]
                        runner.add_filter_rules(**wfilters)
                        runner.prepare_run(t, resultdir=log_dir)
                    except IOError, e:
                        print "[ Error: prepare_run test xml: \
                        %s from testkit-lite failed, error: %s ]\n" % (t, e)
        else:
            for t in testxmls:
                try:
                    wfilters['execution_type'] = ["auto"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(t, resultdir=log_dir)
                except IOError, e:
                    print "[ Error: prepare_run test xml: \
                    %s from testkit-lite failed, error: %s ]\n" % (t, e)
    # run only one tests.xml
    # 1. run all auto cases from the xml
    # 2. run all manual cases from the xml
    else:
        testxml = (options.testxml)[0]
        filename = testxml
        filename = os.path.splitext(filename)[0]
        if platform.system() == "Linux":
            if not filename.startswith('/'):
                print "[ Error: xml file %s should start with '/' ]" % filename
                sys.exit(1)
            else:
                filename = filename.split('/')[-2]
                if filename == "":
                    print "[ Error: unable to find package name info \
                    from %s ]" % testxml
                    sys.exit(1)
        else:
            filename = filename.split('\\')[-2]
        filename = "%s.total" % BASENAME(filename)
        resultfile = "%s.xml" % filename
        resultfile = JOIN(log_dir, resultfile)
        ep = etree.parse(testxml)
        suiteparent = ep.getroot()
        no_test_definition = 1
        for tf in ep.getiterator('test_definition'):
            no_test_definition = 0
        if no_test_definition:
            suiteparent = etree.Element('test_definition')
            suiteparent.tail = "\n"
            for suite in ep.getiterator('suite'):
                suite.tail = "\n"
                suiteparent.append(suite)
        if options.bautoonly:
            wfilters['execution_type'] = ["auto"]
            runner.add_filter_rules(**wfilters)
        if options.bmanualonly:
            wfilters['execution_type'] = ["manual"]
            runner.add_filter_rules(**wfilters)
        runner.apply_filter(suiteparent)
        # just leave suite and set for merge result
        for suite in ep.getiterator('suite'):
            for tset in suite.getiterator('set'):
                for testcase in tset.getiterator('testcase'):
                    tset.remove(testcase)
        try:
            with open(resultfile, 'w') as output:
                tree = etree.ElementTree(element=suiteparent)
                tree.write(output)
        except IOError, e:
            print "[ Error: create filtered result file: \
            %s failed, error: %s ]\n" % (resultfile, e)
            
        START_TIME = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        if not options.bautoonly:
            if options.bmanualonly:
                try:
                    wfilters['execution_type'] = ["manual"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(testxml, resultdir=log_dir)
                except IOError, e:
                    print "[ Error: prepare_run test xml: \
                    %s from testkit-lite failed, error: %s ]\n" % (testxml, e)
            else:
                try:
                    wfilters['execution_type'] = ["auto"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(testxml, resultdir=log_dir)
                    wfilters['execution_type'] = ["manual"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(testxml, resultdir=log_dir)
                except IOError, e:
                    print "[ Error: prepare_run test xml: \
                    %s from testkit-lite failed, error: %s ]\n" % (testxml, e)
        else:
            try:
                wfilters['execution_type'] = ["auto"]
                runner.add_filter_rules(**wfilters)
                runner.prepare_run(testxml, resultdir=log_dir)
            except IOError, e:
                print "[ Error: prepare_run test xml: \
                %s from testkit-lite failed, error: %s ]\n" % (testxml, e)
    try:
        runner.run_case(log_dir)
        runner.merge_resultfile(START_TIME, log_dir)
        print "[ all tasks for testkit lite are accomplished, goodbye ]"
    except Exception, e:
        print "[ Error: run_and_merge_resultfile from testkit-lite failed, \
        error: %s ]\n" % e

except KeyboardInterrupt, e:
    print "\n[ exiting testkit-lite on user cancel ]\n"
    sys.exit(1)
except Exception, e:
    print "\n[ Error: exiting testkit-lite by catching \
    a critical error: %s ]\n" % e
    traceback.print_exc()
    sys.exit(1)
